# processes_and_memory

---

## Обзор процессов

| Команда | Что делает | Зачем / Пример |
| --- | --- | --- |
| `ps aux` | Снимок всех процессов | Видеть PID, CPU, MEM |
| `ps aux --sort=-%cpu | head` | Топ по CPU | Найти «жруна» |
| `ps aux --sort=-%mem | head` | Топ по памяти | Быстро найти утечки |
| `ps -ef --forest` | Дерево процессов | Кто чей родитель |
| `pstree -p` | Дерево с PID | Визуализация иерархии |
| `top` / `htop` | Топ «вживую» | Быстрая навигация по процессам |
| `pidstat 1` | Нагрузка по PID во времени | Видеть всплески CPU/IO/majflt |
| `systemd-cgtop` | Нагрузка по cgroups/юнитам | Понять, какой сервис давит систему |

---

## Управление процессами

| Задача | Команда | Пояснение |
| --- | --- | --- |
| Запустить в фоне | `sleep 300 &` | `&` = background |
| Получить PID последнего фонового | `echo "$!"` | Переменная `$!` |
| Приостановить (SIGSTOP) | `kill -STOP "$PID"` | Жёсткая пауза планировщиком |
| Возобновить (SIGCONT) | `kill -CONT "$PID"` | Продолжить выполнение |
| Вернуть в фон/передний план | `bg %1` / `fg %1` | Для задач из job-control |
| Мягко завершить | `kill -SIGTERM "$PID"` | Дать шанс освободить ресурсы |
| Жёстко завершить | `kill -9 "$PID"` | Только если иное не помогло |
| Убить по имени (точное) | `pkill -x procname` | Матч по имени процесса |
| Убить по шаблону (осторожно) | `pkill -f pattern` | Матч по командной строке |
| Массово по имени | `killall procname` | Может задеть лишнее |
| Сменить nice | `renice -n 10 -p "$PID"` | Ниже приоритет — «тише» по CPU |
| I/O приоритет | `ionice -c2 -n7 -p "$PID"` | Понизить влияние на диск |
| Реал-тайм/приоритет | `chrt -p 0 "$PID"` | Для тонкой настройки планировщика |
| Привязка к ядрам | `taskset -cp 0,1 "$PID"` | Ограничить CPU affinity |

**Подводные камни:** начинать с `SIGTERM`, а не с `SIGKILL`. `pkill -f` легко заденет чужие процессы — предпочитительнее `pkill -x` или конкретный PID.

---

## Сигналы

| Сигнал | Число | Значение |
| --- | --- | --- |
| `SIGTERM` | 15 | Вежливое завершение |
| `SIGKILL` | 9 | Безусловное убийство (не перехватывается) |
| `SIGHUP` | 1 | «Hangup»: многие демоны трактуют как «перечитать конфиг», но это **не гарантия** |
| `SIGINT` | 2 | Прерывание (Ctrl+C) |
| `SIGSTOP` | 19 | Приостановить процесс (не перехватывается) |
| `SIGCONT` | 18 | Продолжить выполнение |

> Важно про зомби: kill -9 не «лечит» зомби. Они исчезают только когда родитель вызывает wait(2). Нужно искать и лечить родителя.
> 

---

## Мониторинг в реальном времени

| Команда | Что делает | Зачем / Пример |
| --- | --- | --- |
| `top` | Динамический мониторинг | Общая картина |
| `htop` | Более удобный `top` | Навигация клавишами |
| `atop` | Углублённый мониторинг (CPU, диски, сеть) |  |
| `iotop` | Топ по I/O (диски) | Где узкое место |
| `glances` | Универсальный монитор | Интерактивный обзор |
| `smem` | Снимок использования памяти с учётом PSS/USS/RSS | Точно найти пожирателей RAM; пример: `smem -t -k -s pss` |

---

## Память: что и как смотреть

| Метрика | Где видно | Что значит | На что смотреть |
| --- | --- | --- | --- |
| **RES (Resident Set Size)** | `top`, `htop` | Реально в RAM. Включает и уникальные, и шареные страницы. | Для понимания нагрузки на систему. |
| **VSZ (Virtual Memory Size)** | `top`, `htop` | Вся виртуалка: mmap-файлы, отложенные аллокации, резервы. | Для диагностики утечек и «почему у меня процесс на сотни ГБ». |
| **USS (Unique Set Size)** | `smem` | Уникальные страницы, принадлежащие только этому процессу. Освободятся при его убийстве. | Чтобы понять «только моё» потребление. |
| **PSS (Proportional Set Size)** | `smem` | «Честная» доля памяти: общие страницы делятся пропорционально. | Самая точная оценка реального расхода процесса. |
| **Swap** | `smem` | Страницы процесса, выгнанные в swap. | Для поиска виновников тормозов при свопинге. |

| Приём | Команда | Пояснение |
| --- | --- | --- |
| Обзор памяти системы | `free -h` | Быстро понять общую картину |
| Память по процессам (PSS) | `smem -p | head` | Требует пакет `smem` |
| Карта памяти процесса | `pmap -x "$PID" | head` | RSS/dirty/anon по участкам |
| Детали по процессу | `grep -E 'VmRSS|VmSize' /proc/$PID/status` | Минимум без утилит |
| Память/своп/состояния | `vmstat 1` | si/so ≠ 0 → идет свопинг |
| История памяти (пакет sysstat) | `sar -r 1` | Тренды |
| Активные swap | `swapon -s` |  |
| Подробно про память | `cat /proc/meminfo` |  |

---

## Диск / сеть и открытые дескрипторы

| Приём | Команда | Пояснение |
| --- | --- | --- |
| Кто жмёт диск | `iotop` | Нужны права и включенная учётка IO |
| Статистика диска | `iostat -xz 1` | Загруженность и задержки |
| Сокеты процессов | `ss -tp` | Быстрее и точнее многих кейсов `lsof` |
| Файлы процесса | `lsof -p "$PID" | less` | Фильтруй по `-p`/`-d` чтобы не тянуть всё |

---

## systemd и cgroups v2

| Приём | Команда | Пояснение |
| --- | --- | --- |
| Дерево cgroups | `systemd-cgls` | Где живёт процесс/юнит |
| Топ по cgroups | `systemd-cgtop` | Кто давит CPU/MEM по юнитам |
| Запуск с лимитом памяти (user) | `systemd-run --user -p MemoryMax=500M cmd` | Быстро ограничить процесс |
| Запуск со scope (root) | `sudo systemd-run -p MemoryMax=300M --scope <cmd>` | В отдельном cgroup-сегменте |
| Ограничить ресурсы сессии | `ulimit -a` | Показать все лимиты |
| Установить лимит памяти | `ulimit -v 500000` | Виртуальная память (KB) |
| Системный уровень | `cat /etc/security/limits.conf` | Лимиты для пользователей |

---

## OOM и PSI

| Приём | Команда | Пояснение |
| --- | --- | --- |
| Логи OOM | `journalctl -k -g 'Out of memory' -g 'oom' --since today` | Кто и когда отстрелен |
| Баллы OOM | `cat /proc/$PID/oom_score{,_adj}` | Вклад процесса в OOM |
| Давления PSI | `cat /proc/pressure/{cpu,io,memory}` | Видно, «захлёбывается» ли система |

---

## Практикум

1. **Запустить процесс и поймать его PID**
    
    ```bash
    sleep 300 &PID="$!"echo "PID=$PID"ps -p "$PID" -o pid,ppid,stat,etime,cmd
    ```
    

2. **Приостановить и возобновить**
    
    ```bash
    kill -STOP "$PID"sleep 2
    ps -p "$PID" -o pid,stat,etime
    kill -CONT "$PID"
    ```
    

3. **Понизить приоритеты**
    
    ```bash
    renice -n 10 -p "$PID"ionice -c2 -n7 -p "$PID"
    ```
    

4. **Безопасно завершить по имени**
    
    ```bash
    pkill -x sleep || true
    ```
    

5. **Посмотреть топовые процессы**
    
    ```bash
    ps aux --sort=-%cpu | head
    ps aux --sort=-%mem | head
    ```
    

6. **Открытые файлы и сокеты процесса**
    
    ```bash
    lsof -p "$PID" | head
    ss -tp | head
    ```
    

7. **История по PID во времени**
    
    ```bash
    pidstat 1 5
    ```
    

8. **Ограничить память процессу (root, scope)**
    
    ```bash
    sudo systemd-run -p MemoryMax=300M --scope bash -lc 'stress-ng --vm 1 --vm-bytes 400M --timeout 20s'systemd-cgtop
    ```
    

9. **Проверить OOM и PSI**
    
    ```bash
    journalctl -k -g 'Out of memory' -g 'oom' --since today
    cat /proc/pressure/{cpu,io,memory}
    ```
    

---

## Security Checklist

- Проверять процессы от **неожиданных пользователей**: `ps aux | grep nobody`
- Следить за SUID-бинарниками: `sudo find / -perm -4000 -type f -xdev 2>/dev/null`
- Проверить capability: `getcap -r / 2>/dev/null` — тонкие права на бинарях

---

## Быстрые блоки

```bash
ps aux --sort=-%cpu | head     # Топ-10 по CPU
ps aux --sort=-%mem | head     # Топ-10 по MEM
ps -ef --forest | head -40     # Дерево процессов (альтернатива pstree)
sudo pkill -u username         # Убить все процессы пользователя (осторожно)
lsof -p PID | less             # Показать открытые файлы процесса
sar -r 1 10                    # История памяти (sysstat)
```