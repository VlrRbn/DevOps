# variables_and_constructs

---

## Аргументы скрипта

- `$0` — имя скрипта
- `$1`, `$2`, … — позиционные аргументы
- `$#` — количество аргументов
- `$@` — все аргументы как **отдельные** слова (`"$@"` — правильно форвардить)
- `$*` — все аргументы **одной строкой** (склеит по `IFS`; почти всегда не то)
- `shift` — сдвиг аргументов влево (удалить `$1`, `$2`→`$1` и т.д.)

```bash
# Пример разницы "$@" vs "$*"
set -- "a b" c
for x in "$@"; do printf '[%s]\n' "$x"; done   # [a b] [c]
for x in "$*"; do printf '[%s]\n' "$x"; done   # [a b c]
```

---

## Статусы и процессы

- `$?` — код возврата последней команды (0 = успех)
- `$$` — PID текущего скрипта
- `$!` — PID последнего фонового процесса (`&`)
- `$_` — последний аргумент предыдущей команды (в интерактиве может отличаться в скриптах)
- `PIPESTATUS[@]` — коды возврата **каждой** команды в пайплайне слева направо

```bash
cmd1 | cmd2 | cmd3
echo "${PIPESTATUS[@]}"     # Например: 0 0 1
job & pid=$!; wait "$pid"; rc=$?; echo "job rc=$rc"
```

---

## Переменные и их расширения

- `${var}` — значение
- `${#var}` — длина строки

### Значения по умолчанию / присвоения

- `${var:-word}` — если **пусто или не задана**, использовать `word`
- `${var:=word}` — если **пусто или не задана**, присвоить `word`
- `${var:+alt}` — если переменная **задана**, использовать `alt`, иначе пусто
- `${var-word}` — если **не задана** (но пустая считается заданной), использовать `word`
- `${var=word}` — если **не задана**, присвоить `word`
- `${var:?msg}` — аварийно завершиться с `msg`, если пусто/не задана

### Усечения префиксов/суффиксов

- `${var#pattern}` / `${var##pattern}` — убрать кратчайший/самый длинный **префикс**
- `${var%pattern}` / `${var%%pattern}` — убрать кратчайший/самый длинный **суффикс**

### Подстроки / замены / регистры

- `${var:offset:length}` — подстрока
- `${var/pat/repl}` — заменить первое; `${var//pat/repl}` — все; `${var/#pat/repl}` — в начале; `${var/%pat/repl}` — в конце
- `${var^}` / `${var^^}` — сделать первую/все буквы заглавными; `${var,}` / `${var,,}` — строчные

```bash
f="/var/log/nginx/access.log"
echo "${f##*/}"                       # access.log
echo "${f%/*}"                        # /var/log/nginx
s="hello"; echo "${s^} ${s^^}"        # Hello HELLO
msg="abc abc"; echo "${msg//a/A}"     # Abc Abc
```

---

## Кавычки и подстановки

- Рекомендуется `$(cmd)` вместо обратных кавычек ``cmd``
- «Кавычить всё, что не арифметика»: `"$var"`, `"${arr[@]}"` и т.д.
- Here-string / Heredoc: `<<< "text"` и `<<'EOF' ... EOF` (с кавычками — без подстановок)

```bash
name=$(whoami)
grep -i "error" <<< "$line"
cat <<'EOF'
$HOME не подставится здесь
EOF
```

---

## Массивы (индексные)

- Объявление: `arr=(a b c)`
- Доступ: `${arr[0]}`, `${arr[@]}` — элементы; `${#arr[@]}` — длина; `${!arr[@]}` — индексы
- Итерация: `for x in "${arr[@]}"; do ...; done`

```bash
arr=(alpha beta)
arr+=("gamma")
printf '%s\n' "${!arr[@]}"     # 0 1 2
printf '%s\n' "${arr[@]}"      # alpha beta gamma
```

### Ассоциативные массивы

- `declare -A map; map[key]="value"; echo "${map[key]}"`
- Важно: при `set -u` доступ к несуществующему ключу — ошибка

```bash
declare -A ports=([http]=80 [https]=443)
for k in "${!ports[@]}"; do
	printf '%s -> %s\n' "$k" "${ports[$k]}"; 
done
```

---

## Условия и тесты

- `[[ ... ]]` — безопаснее и функциональнее, чем `[ ... ]`: не глотает глобы, есть `=~`  сопоставление с регулярным выражением
- Строки: `[[ a = b ]]`, `[[ a != b ]]`, `[[ a < b ]]`, `[[ -z $s ]]`, `[[ -n $s ]]`
- Числа: `-eq -ne -lt -le -gt -ge`
- Файлы: `-e -f -d -s -x -r -w`, сравнения по времени `-nt -ot`

```bash
if [[ $name =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then echo ok; fi
case "$ext" in
	jpg|png) echo "image" ;;
	*)       echo "other" ;;
esac
```

---

## Циклы и перечисления

- `for i in {1..5}; do ...; done` — брейс-генерация
- `for x in "${arr[@]}"; do ...; done` — по массиву
- `while read -r line; do ...; done < file` — построчно
- `until cmd; do ...; done` — пока команда **проваливается**

```bash
for i in {01..03}; do echo "part$i"; done
n=0
while IFS= read -r line; do
  ((n++))
  printf '%5d: %s\n' "$n" "$l"
done < /etc/hosts
```

---

## Ввод-вывод и редиректы

- `>` перезаписать, `>>` дописать
- `2>` **stderr** в файл, `1>` — **stdout** в файл `&>` **stdout+stderr** вместе, `2>&1` — **stderr** туда же, куда stdout, `1>&2` — **stdout** туда, куда stderr
- Подстановка процессов: `<(cmd)` как файл для чтения, `>(cmd)` — для записи

```bash
diff -u <(cmd_a) <(cmd_b)            # Сравнение вывода двух команд построчно
tee out.log >(grep -i error >&2)     # Записать вывод в cmd
```

---

## Арифметика: `$(( ... ))` и `(( ... ))`

- В Bash — **целые**; `3/2 → 1`. Для дробей — `bc`/`awk`
- `(( expr ))` — код возврата как булево (0 = истина)
- Инкременты/накопления: `((i++))`, `((sum+=n))`

```bash
n=5;
echo $((n+1))                                # 6
if (( (n % 2) == 1 )); then echo odd; fi     # true, если результат ≠ 0
echo "scale=2; 3/2" | bc                     # 1.50
```

---

## Надёжность скриптов

- `set -Eeuo pipefail`
    - `-E` — сохраняет поведение `ERR` в функциях и сабшеллах
    - `-e` — останавливать на ошибках (осторожно: внутри `if`, `&&/||`, пайпов)
    - `-u` — ошибка при обращении к несуществующим переменным
    - `-o pipefail` — пайплайн «падает» если упала любая команда
- `IFS=$'\n\t'` — меняет разделители слов на перевод строки и табуляцию
- `trap 'handler' ERR` — единая точка логирования ошибок
- Явно указывать `#!/usr/bin/env bash`

```bash
#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'
err() { echo "[$(date +%T)] ERROR at ${BASH_SOURCE[0]}:${LINENO[1]}: $@" >&2; }
trap 'rc=$?; err "$rc"; exit "$rc"' ERR
```

---

## Минимальный скелет скрипта

```bash
#!/usr/bin/env bash
set -Eeuo pipefail
IFS=$'\n\t'

usage(){ echo "Usage: ${0##*/} [-n NUM] [-s STR] [--] file"; }
num=0; str=""; file=""

while getopts ":n:s:h" opt; do
  case "$opt" in
    n) num="$OPTARG" ;;
    s) str="$OPTARG" ;;
    h) usage; exit 0 ;;
    :) usage >&2; exit 2 ;;
    \?) usage >&2; exit 2 ;;
  esac
done
shift $((OPTIND-1))

[[ "${1:-}" == "--" ]] && shift

if [[ $# -gt 0 ]]; then
  file=$1; shift
fi

[[ -n "$file" ]] || { echo "file is required" >&2; usage >&2; exit 2; }

main(){
  echo "num=$num str=$str file=$file"
}
main "$@"
```