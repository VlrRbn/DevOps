# 05-07 Operations Bridge (После Уроков 5-7)

**Цель:** собрать все подробные объяснения в один файл, но отсортировать их по урокам 5, 6 и 7.

**Как читать:**

- сначала блок нужного урока;
- затем общий FAQ/чеклист/мини-лаба.

---

## Урок 05: systemd, journald, диагностика сервисов

### Systemd + journald: объяснение

#### Что такое unit

Unit = объект, которым управляет systemd:

- service;
- timer;
- socket и т.д.

#### Базовый triage flow

1. `systemctl status <unit>`
2. `journalctl -u <unit> ...`
3. если нужно: фильтр по приоритету и времени

#### Почему `--no-pager`

Чтобы вывод шел прямо в терминал/скрипт, без `less`.

#### Почему `sed -n '1,12p'`

Чтобы взять только верхушку status (короткий summary), а не экран текста.

#### Фильтр по приоритетам

```bash
journalctl -u cron -p warning --since "1 hour ago"
```

Что значит:

- `-u cron` -> только логи unit `cron`;
- `-p warning` -> warning и серьезнее;
- `--since` -> ограничение по времени.

#### Follow mode

```bash
journalctl -u cron -f
```

Поток "живых" логов до `Ctrl+C`.

---


---

## Урок 06: APT/DPKG, restore, unattended-upgrades

### APT/DPKG: как это связано с уроком 6 и bridge

#### Кто за что отвечает

- `apt` -> удобно вручную в терминале;
- `apt-get` -> стабильнее для скриптов;
- `apt-cache` -> запрос метаданных;
- `dpkg` -> локальная база и установленное состояние.

#### Что такое Candidate

В `apt-cache policy`:

- `Installed` = установленная версия;
- `Candidate` = версия, которую apt выберет прямо сейчас.

Если они разные, обычно доступно обновление.

#### Что такое `500`

Это Pin-Priority источника. Это не "процент" и не "качество".

Быстрый ориентир:

- `100` -> локальный статус установленного;
- `500` -> обычный репозиторий;
- `990` -> target release;
- `1001+` -> принудительное предпочтение.

#### Hold

```bash
sudo apt-mark hold htop
apt-mark showhold
sudo apt-mark unhold htop
```

Зачем:

- временно не обновлять конкретный пакет.

Риск:

- забыть hold и долго жить на старой версии.

#### Почему simulation-first

```bash
sudo apt-get -s upgrade
sudo apt-get -s full-upgrade
```

Это превью: что **будет**, но без реальных изменений.

---


### Restore через selections: что откуда и зачем

#### Snapshot

```bash
dpkg --get-selections > packages.list
dpkg -l > packages_table.txt
```

Разница:

- `packages.list` -> машинно-читаемый список для restore;
- `packages_table.txt` -> удобный "человеческий" снимок.

#### Simulate restore

```bash
sudo dpkg --set-selections < packages.list
sudo apt-get -s dselect-upgrade
```

Смысл:

- сначала применяем желаемые selections;
- потом смотрим, что система реально собирается сделать.

#### Apply restore

```bash
sudo apt-get -y dselect-upgrade
```

Только после проверки simulation.

---


### Unattended-upgrades: откуда, зачем, где осторожно

#### Что это

Механизм авто-обновлений (часто security), чтобы не ждать ручного `apt upgrade`.

#### Где полезно

- серверы, где нужны регулярные security patching;
- инфраструктура с ограниченным ручным сопровождением.

#### Где осторожно

- строгий change management;
- системы, где обновления проходят только через staging/approval.

#### Безопасная проверка

```bash
sudo unattended-upgrade --dry-run --debug | sed -n '1,80p'
systemctl list-timers --all | grep -E 'apt-daily|apt-daily-upgrade'
journalctl -u apt-daily-upgrade.service -n 50 --no-pager
```

---


---

## Урок 07: Bash-скриптинг и безопасная автоматизация

### Как читать команды (самая важная часть)

Этот раздел специально вынесен в начало, потому что большинство непонимания появляется не из-за "сложной Linux-магии", а из-за синтаксиса.

#### Что значат скобки и символы в документации

Когда видишь в тексте:

- `<name>` -> это **заполнитель**, подставь свое значение.
- `[--flag]` -> опция **необязательная**.
- `A | B` -> либо `A`, либо `B`.
- `...` -> можно продолжить по аналогии.

Пример:

```bash
script.sh <src_ext> <dst_ext> <dir> [--dry-run]
```

Это значит:

- `src_ext`, `dst_ext`, `dir` обязательны;
- `--dry-run` можно добавить, а можно нет.

#### Одинарные и двойные кавычки

- `'...'` (одинарные) -> почти ничего внутри не подставляется.
- `"..."` (двойные) -> переменные типа `$name` подставятся.

Пример:

```bash
name="world"
echo '$name'
echo "$name"
```

Ожидаемо:

- первая строка выведет буквально `$name`;
- вторая выведет `world`.

#### Что значит `$name`, `${name}`, `$(...)`

- `$name` -> значение переменной `name`.
- `${name}` -> то же, но удобно рядом с текстом.
- `$(command)` -> подставь результат команды.

Пример:

```bash
base="backup"
echo "${base}_$(date +%Y%m%d)"
```

#### Что такое `%s` и `\n` в `printf`

Пример из твоего вопроса:

```bash
name="a b.txt"
printf '%s\n' "$name"
```

Разбор:

- `printf` печатает текст по шаблону;
- `%s` = "подставь строку";
- `\n` = "перевод строки";
- итого: напечатать строку из `name` и перейти на новую строку.

Почему не `echo`:

- `printf` ведет себя предсказуемее в скриптах.

#### Что значит `2>/dev/null`, `|| true`, `&&`

- `2>/dev/null` -> отправить **ошибки** (stderr) в "черную дыру".
- `cmd || true` -> если `cmd` упала, не валить весь скрипт.
- `cmd1 && cmd2` -> `cmd2` выполняется только если `cmd1` успешна.

#### Что делает `--`

`--` часто означает: "дальше только аргументы, не опции".

Полезно, если имя файла начинается с `-`.

```bash
rm -- -strange-file
```

---


### Контекст запуска скрипта и интерпретатор

#### Shebang: откуда и зачем

Первая строка скрипта:

```bash
#!/usr/bin/env bash
```

Это инструкция ядру Linux: каким интерпретатором запускать файл.

Два популярных варианта:

- `#!/bin/bash` -> фиксированный путь.
- `#!/usr/bin/env bash` -> найти bash через `PATH`.

Почему чаще используют `env`:

- скрипт переносимее между системами;
- меньше хардкода.

#### Три способа запуска и почему это важно

1. `bash script.sh`
2. `./script.sh`
3. `script.sh`

Разница:

- `bash script.sh` -> запускаешь явно через bash, execute-bit не обязателен.
- `./script.sh` -> запускаешь файл как программу в текущей папке, нужен execute-bit.
- `script.sh` -> shell ищет в `PATH`; если текущая папка не в `PATH`, будет `command not found`.

#### Почему "файл есть, но не запускается"

Проверь по порядку:

```bash
ls -l script.sh
head -n 1 script.sh
file script.sh
```

Смотри:

- есть ли `x` в правах;
- корректный ли shebang;
- не CRLF ли у файла.

#### Мини-практика

```bash
mkdir -p ~/bridge57/context && cd ~/bridge57/context
cat > hello.sh <<'EOF'
#!/usr/bin/env bash
echo "hello"
EOF

bash hello.sh
chmod +x hello.sh
./hello.sh
```

Если все ок, увидишь `hello` в обоих случаях.

---


### Коды возврата и логика выполнения

#### Что такое exit code простыми словами

Каждая команда в Linux завершает работу числом:

- `0` -> все хорошо;
- не `0` -> что-то пошло не так (или "ничего не найдено", как у `grep`).

Проверка:

```bash
true; echo "$?"
false; echo "$?"
```

#### Почему это важно в скриптах

Скрипт принимает решения по коду возврата:

- продолжать;
- падать;
- перейти в fallback.

#### `&&`, `||` на живом примере

```bash
mkdir -p /tmp/demo && echo "dir ok"
ls /not-exists || echo "fallback"
```

Разбор:

- во второй строке `ls` упадет;
- `||` запустит `echo` справа.

#### Где часто путаются

`grep` без совпадений возвращает `1`. Это не "поломка мира", но код не ноль.

В строгом скрипте (`set -e`) это может оборвать выполнение. Поэтому иногда пишут:

```bash
grep "needle" file || true
```

Это осознанный сигнал: "здесь ошибка допустима".

---


### Strict mode: зачем в каждом ops-скрипте

#### `set -Eeuo pipefail` по частям

- `-e` -> завершить скрипт при ошибке команды.
- `-u` -> завершить скрипт при обращении к несуществующей переменной.
- `pipefail` -> пайплайн считается ошибкой, если упала **любая** команда в нем.
- `-E` -> trap ERR работает глубже (в функциях).

#### Что делает `IFS=$'\n\t'`

`IFS` задает, как shell делит текст на слова.

По умолчанию туда входит пробел. Это опасно для путей с пробелами.

`IFS=$'\n\t'` отключает разделение по пробелу.

#### Trap ERR

```bash
trap 'echo "ERR:$? at ${BASH_SOURCE[0]}:${LINENO}" >&2' ERR
```

Разбор:

- `$?` -> код ошибки;
- `${BASH_SOURCE[0]}` -> имя файла;
- `${LINENO}` -> строка;
- `>&2` -> печатать в stderr.

#### Trap EXIT для cleanup

```bash
tmp="$(mktemp -d)"
cleanup() {
  rm -rf "$tmp"
}
trap cleanup EXIT
```

Плюс:

- временные файлы не остаются мусором даже при ошибке.

---


### Quoting и подстановки без боли

#### Базовое правило

Если переменная может содержать пробелы, почти всегда используй кавычки:

```bash
rm -f "$file"
```

#### Разница `echo` и `printf`

Для скриптов часто лучше `printf`:

```bash
name="a b.txt"
printf '%s\n' "$name"
```

Это более контролируемый вывод.

#### `${f%"$src"}` из rename-скриптов

Пример:

```bash
f="/tmp/a.txt"
src=".txt"
dst=".md"
new="${f%"$src"}$dst"
```

Что произошло:

- отрезали суффикс `.txt`;
- добавили `.md`;
- получили `/tmp/a.md`.

#### `${var:-default}`

```bash
echo "${APP_ENV:-dev}"
```

Если `APP_ENV` не задана, будет `dev`.

Зачем:

- скрипт не падает от пустого окружения;
- поведение заранее определено.

---


### Командные массивы: фундамент безопасной динамики

#### Почему строка-команда плоха

Плохой паттерн:

```bash
cmd="tar -czf $tarball $dir"
$cmd
```

Проблема:

- shell повторно разбивает строку на слова;
- пробелы и спецсимволы ломают аргументы.

#### Правильный паттерн

```bash
cmd=(tar -czf "$tarball" "$dir")
"${cmd[@]}"
```

Плюсы:

- каждый аргумент отделен корректно;
- безопасно для путей с пробелами;
- легко добавлять условные флаги.

#### Условный аргумент

```bash
[[ -n "$exclude" ]] && cmd+=("--exclude=$exclude")
```

Если `exclude` пуст, аргумент не добавится.

---

### `getopts`: как читать и писать разбор флагов

#### Что делает `getopts`

`getopts` разбирает короткие CLI-флаги (`-n`, `-v`, `-f value`) внутри shell-скрипта.

Это лучше ручного разбора, потому что:

- логика чище;
- меньше багов с порядком аргументов;
- легче показывать корректный usage.

#### Базовый шаблон

```bash
dry=0
verbose=0
since=""

while getopts ":nvs:" opt; do
  case "$opt" in
    n) dry=1 ;;
    v) verbose=1 ;;
    s) since="$OPTARG" ;;
    \?) echo "Unknown option: -$OPTARG" >&2; exit 1 ;;
    :) echo "Option -$OPTARG requires a value" >&2; exit 1 ;;
  esac
done
shift $((OPTIND-1))
```

Как читать `:nvs:`:

- `n` и `v` — флаги без значения;
- `s:` — флаг, который требует значение;
- ведущий `:` позволяет отдельно обрабатывать “нет значения у флага”.

#### Где чаще ошибаются

- забывают `shift $((OPTIND-1))`, и позиционные аргументы “съезжают”;
- не обрабатывают кейс “флагу нужно значение”;
- смешивают `getopts` и ручной парсинг без явной схемы.

---



### Безопасный обход файлов и массовые операции

#### Почему `for f in $(find ...)` опасен

Потому что:

- пробелы в именах ломают список;
- переносы строк ломают список.

#### Надежная схема

```bash
find "$dir" -type f -print0 |
  while IFS= read -r -d '' f; do
    printf '%s\n' "$f"
  done
```

Почему так:

- `-print0` разделяет NUL-байтом;
- `read -d ''` читает до NUL;
- `IFS=` + `-r` сохраняют оригинальное имя файла.

#### Когда нужен `xargs -0`

Для удаления/обработки пакетно:

```bash
find "$dir" -type f -name '*.tmp' -print0 | xargs -0 -r rm -f
```

- `-0` = NUL input;
- `-r` = не запускать команду без входных данных.

---


### Backup-логика из lesson 07: полный разбор

#### Что делает backup-скрипт по шагам

1. валидирует аргументы;
2. готовит путь архива;
3. делает архив через `tar`;
4. валидирует архив;
5. делает ротацию старых копий;
6. пишет событие в лог.

#### Почему `tar -C` критичен

```bash
tar -C "$(dirname -- "$dir")" -czf "$tarball" "$(basename -- "$dir")"
```

Зачем:

- внутри архива остается относительная структура;
- меньше сюрпризов при restore.

#### Валидация перед ротацией

```bash
tar -tzf "$tarball" >/dev/null
```

Смысл:

- если архив плохой, ротация не должна удалить старые рабочие копии.

#### Retention (оставить N)

Типовой пайплайн:

- список архивов;
- сортировка по времени;
- пропустить первые N;
- удалить хвост.

Это работает, если входные пути обрабатываются безопасно.

#### Исключения (`--exclude`)

Нужны, чтобы не архивировать:

- временные файлы;
- кэш;
- очень тяжелые директории.

Важно:

- сначала проверить шаблон на тестовых данных.

---

### `flock`: защита от параллельных запусков

#### Зачем это нужно

Если скрипт запускается из `cron`/`timer`, два экземпляра могут пересечься и испортить результат (особенно backup/rotation).

`flock` делает “single-instance” запуск.

#### Базовый паттерн

```bash
lock="/tmp/backup-${base}.lock"
{
  flock -n 9 || { echo "Another run is in progress" >&2; exit 1; }
  # critical section
  ./do-work.sh
} 9>"$lock"
```

Что здесь важно:

- `-n` — не ждать lock бесконечно;
- `9>"$lock"` — file descriptor для lock-файла;
- если lock уже занят, скрипт корректно завершается.

#### Проверка вживую

Запусти скрипт дважды подряд. Второй запуск должен быстро завершиться с понятным сообщением.

---

### `logger` и наблюдаемость скриптов

#### Зачем это в ops-скриптах

`echo` в терминал — временно.  
`logger` отправляет события в системный журнал, и их можно позже достать через `journalctl`.

#### Минимальный паттерн

```bash
logger -t backup "Created archive: $tarball"
logger -t backup "Rotation completed (keep=$keep)"
```

Проверка:

```bash
journalctl -t backup -n 50 --no-pager
```

#### Практическое правило

- логируй ключевые этапы (start, success, failure);
- добавляй context (файл, unit, количество, длительность);
- не логируй чувствительные данные.

---




---

## Общее: FAQ, чеклист, deep-лаба и что дальше

### Частые вопросы (FAQ)

#### Почему `./script.sh` работает, а `script.sh` нет?

Потому что `script.sh` ищется в `PATH`, а текущая папка обычно туда не входит.

#### Почему `echo` иногда "странно" себя ведет?

Потому что `echo` по-разному трактует спецсимволы в разных shell/режимах. В скриптах часто безопаснее `printf`.

#### Почему команда с `grep` "упала", если просто ничего не нашла?

Потому что "не найдено" для `grep` это exit code `1`.

#### Почему скрипт удалил не те файлы?

Обычно из-за:

- unquoted переменных;
- unsafe обхода файлов (`for f in $(...)`).

#### Что сначала учить: systemd или bash?

В твоем треке правильно идет связка:

- сначала базовый bash safety;
- потом systemd/journal helper-скрипты.

---


### Диагностический чеклист перед коммитом скрипта

Перед коммитом прогони:

```bash
bash -n script.sh
shellcheck script.sh
```

И вручную проверь:

- корректный `--help`/usage;
- обработка неправильных аргументов;
- поведение на путях с пробелами;
- dry-run (если есть);
- безопасный fallback на ожидаемые ошибки.

---


### Deep Mini-Lab (45-60 минут)

Этот лаб объединяет уроки 5-7 в один цельный прогон.

#### Шаг 1. Подготовка среды

```bash
mkdir -p "/tmp/deep57/a b"
: > "/tmp/deep57/a b/one file.txt"
: > "/tmp/deep57/a b/two file.txt"
```

#### Шаг 2. Dry-run rename

```bash
./lessons/07-bash-scripting-automation/scripts/rename-ext.v2.sh -nv txt md "/tmp/deep57"
```

Проверь, что вывод показывает корректные пары old -> new.

#### Шаг 3. Real rename

```bash
./lessons/07-bash-scripting-automation/scripts/rename-ext.v2.sh -v txt md "/tmp/deep57"
```

#### Шаг 4. Backup с retention

```bash
./lessons/07-bash-scripting-automation/scripts/backup-dir.v2.sh "/tmp/deep57" --keep 2
./lessons/07-bash-scripting-automation/scripts/backup-dir.v2.sh "/tmp/deep57" --keep 2
ls -1t "$HOME"/backups/deep57_* | head -n 5
```

#### Шаг 5. Проверка логов backup

```bash
journalctl -t backup -n 20 --no-pager
```

#### Шаг 6. Unit triage

```bash
./lessons/07-bash-scripting-automation/scripts/devops-tail.v2.sh cron -s "1 hour ago" -n 100 || true
```

#### Шаг 7. APT simulation

```bash
sudo apt update
sudo apt-get -s upgrade | sed -n '1,40p'
```

#### Шаг 8. Cleanup

```bash
rm -rf /tmp/deep57
```
